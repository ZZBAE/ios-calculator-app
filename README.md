# 🧮 계산기 프로젝트 (Calculator)
> 프로젝트 기간 2022.05.16 월  ~ 2022.05.18 수 </br>
팀원: 재재</br>
리뷰어: Ryan
---

## 💾개발환경 및 라이브러리
[![swift](https://img.shields.io/badge/swift-5.6-orange)]()
[![xcode](https://img.shields.io/badge/Xcode-13.3-blue)]()

## 👩🏻‍💻 프로젝트 진행 방식
- 이번 프로젝트를 수행함에 있어 꼭 읽고 참고해야하는 공식 문서 빠짐없이 읽고 공부하기
- Step 1 수행 중 핵심경험 체크 ➡️ 왜 필요할지 생각하기
- 순서도와 UML 작성 필수
- 모르거나 헷갈리는 부분 꼭 꼭 질문하기

## 💡Step 1 수행 중 핵심경험
- [x] TDD 시작하기
- [x] 기존의 프로젝트에 Test Target 추가
- [x] Queue 자료구조의 이해와 구현

## 🗺 UML
<img width="705" alt="스크린샷 2022-05-18 오후 3 51 48" src="https://user-images.githubusercontent.com/98302604/168981981-391409f5-9e3c-4199-8577-8afb12b5a310.png">


## 😖제일 고민했던 부분
- UML : 전에 했던 쥬스메이커 프로젝트에서 리뷰어 그린의 추천으로 UML 그려도보고 학습활동으로 연습도 해보았는데, 내가 만들어야하는 프로젝트의 UML을 백지상태에서 짜는게 상당히 고민됐었다. 어디서부터 시작해야하는지도 모르겠고 class나 struct에 맞춰서 칸은 만들어놨는데 뭘 적어야할지 애매했다. 그래도 flowchart처럼 전반적인 흐름과 각 객체간의 연관 관계를 생각하면서 천천히 하나씩 하다보니까 어느정도 UML같은게 완성은 됐던 것 같다.

## 🏀TroubleShooting (고민한점, 해결한점)
1. **우선 CalculatorItemQueue 내부에서 연산정보를 담는 큐를 구현할 수 있는 자료형식은 3가지 방법이 있습니다.**

1-1. 배열

<img width="658" alt="스크린샷 2022-05-18 오후 4 44 30" src="https://user-images.githubusercontent.com/98302604/168988056-f2712d96-fbec-4f27-b383-52beee3c74ba.png">

[사진출처](https://babbab2.tistory.com/86)

index를 이용하여 메모리 공간 위에 나란히 나열을 해놓는 구조입니다.</br>접근이 빠르다는 장점이 있지만 한 element를 삭제하거나 삽입할 때, 하나씩 자리를 바꿔줘야하는 번거로움이 생깁니다.


1-2. LinkedList

<img width="753" alt="스크린샷 2022-05-18 오후 5 03 10" src="https://user-images.githubusercontent.com/98302604/168989343-d7f6e0e2-5ffc-4426-9347-f6615147de9f.png">

[사진출처](https://babbab2.tistory.com/86)

각각의 공간에 있는 데이터를 연결시켜주는 구조입니다.</br>이 경우, 배열처럼 재배치를 하지 않아도 되기 때문에 중간에 element를 수정해도 괜찮다는 장점이 있지만, 데이터를 담는 별도의 공간이 많이 필요하기 때문에 저장 공간의 효율과 데이터를 찾는 속도가 느려진다는 단점이 있습니다.

1-3. DoubleStack

<img width="576" alt="스크린샷 2022-05-18 오후 5 10 19" src="https://user-images.githubusercontent.com/98302604/168990488-15cf8640-f1fc-4e15-b2c2-a2e2c3cf2896.png">

[사진출처](https://limjs-dev.tistory.com/90)


stack을 2개를 구현하여 처음 stack에 들어온 값들의 순서를 뒤바꿔주어 두번째 stack에서 element를 재배열 없이 그대로 뺄 수 있다는 장점이 있습니다. 저는 이 자료구조가 조금 더 이해가 되는 것 같아서 DoubleStack을 구현해주었습니다!

2. **TDD를 구현했는데, Test를 어떤식으로 시작해야할지 감이 안와서 오래걸렸던 것 같습니다.**
```swift
class CalculatorItemQueueTests: XCTestCase {
    var sut: CalculatorItemQueue<Int>?
    
    override func setUpWithError() throws {
        sut = CalculatorItemQueue()
    }
    
    override func tearDownWithError() throws {
        sut = nil
    }
    
    func test_1을_enqueue하면_1이_있다() {
        //given
        sut?.enqueue(1)
        
        //when
        let enqueueData = sut?.peek
        
        //then
        XCTAssertEqual(1, enqueueData)
    }
}
```
위와 같이 변수 sut(system under test)를 만들어주고, setUpWithError()와 tearDownWithError()를 이용해 하나의 테스트를 실행할 때마다 다음 테스트에 방해가 가지 않게 비워주는 역할을 할당해주었습니다. test에 각각 숫자를 랜덤으로 넣어서 enqueue와 dequeue, count, peek, isEmpty 를 순차적으로 테스트해보았습니다. 

---


## ⁉️조언을 구하고 싶은 부분
## Calculator Step 1 Review (by. Ryan)

1. 아쉬운점 : commit 메세지를 이해하기 어려움
    - commit : what, how
    - PR : what, how, why
    - 개별commit : how

그 당시에 필요했어도 의미없는 커밋이면, interactive rebase 를 이용해 불필요한 커밋을 하나로 합쳐주는 것도 방법!

**Interactive rebase 방법**</br>
git rebase : 일반적으로 리베이스라고 하면 두 개의 브랜치를 합치는 용도로 git merge 와 함께 쓰이는 것, 현재 작업중인 브랜치의 최신 커밋을 가리키는 HEAD 포인터를 이동시킬 수 있다는 특성을 이용해서 과거 커밋 히스토리를 수정하는 데에도 사용할 수 있다. 특히 그 중에서도 대화형으로 실행할 수 있는 옵션인 --interactive (또는 -i) 를 이용한다면 더욱 쉽게 수정이 가능하다.

[링크참고](https://wormwlrm.github.io/2020/09/03/Git-rebase-with-interactive-option.html)

2. TDD
>TDD는 원래 실패가능한 테스트로 코드를 짜기 전에 해야하는 것이라고 배웠는데, 사실 이번 프로젝트를 진행하면서 실패가능성을 어떤 식으로 생각해야하는지 감이 오지 않아 결국 코드를 먼저 만들어보고 그거에 대한 테스트 타켓을 만들게 되었습니다🥲 혹시 TDD를 만들 때, 메서드의 분리나 처음 작성할 때 애매한 부분들을 어떤식으로 해결해야하는지 라이언의 조언을 듣고 싶습니다..!

실패하는 테스트란 용어는 최초에 바로 이해하기 어렵긴 합니다. 하지만 아무것도 구현되지 않은 상태에서 테스트를 짠다면 반드시 실패하는 테스트겠죠. 바로 그 의미입니다.
예를 들어볼게요. 어떤 방식을 이용해서 큐를 구현하든 큐가 가지는 기본적인 특징이 있습니다. 선입선출과 같은 것이죠. 이를 통해 구현된 코드가 아무것도 없는 상태에서 테스트 스펙을 결정하고 테스트 코드도 짤 수 있습니다.
- 큐가 비어있을 때 요소 넣기 -> 큐에는 새로 넣은 요소가 있고 큐에 들어있는 요소 개수는 새 요소 개수
- 큐에 요소가 있을 때 새 요소 넣기 -> 큐에는 이전의 요소 뒤에 새로 넣은 요소가 위치하고 개수는 기존 + 새 요소 개수
    * 이 경우 큐의 첫번째 요소, 마지막 요소 조회를 위한 구현이 추가될 수 있으나 어떠한 경우에도 안정적으로 동작함을 보장하기 위해 테스트 스펙으로 정할 수 있음
- 큐가 비어있을 때 요소 빼기 -> nil 또는 에러 던지기, 에러 반환 등 다양한 정책 수립 가능
- 큐에 요소가 있을 때 요소 1개 빼기 -> 반드시 먼저 들어간 요소가 먼저 나온다는 원칙을 준수함을 보장, 큐를 구현한 방식의 특징을 잘 고려하여 특정 구간에서 특이하게 작동하는 경우 (edge case)가 없는지 점검하고, 만약 있으면 반드시 테스트 케이스에 추가한다.

구현된 것이 없어도 이 내용은 테스트로 작성이 가능할거에요. 바로 코드 작성이 어렵다면 주석을 통해 의사코드로 작성하실 수도 있고요. TDD는 이러한 테스트 케이스를 하나씩 정의하고 구현해나가는 개발방법론이에요 (모든 스펙을 한꺼번에 정의하고 한꺼번에 구현하는 것은 매우 어려워요).

이렇게 타입 요구사항을 테스트로 작성하셨다면 이제 이 테스트 스펙을 통과할 수 있는 타입을 구현하시면 됩니다. 테스트가 통과한다면 이제 코드를 예쁘게 고치고 구조화하는거죠.

3. UML
UML을 혼자서 처음 작성해보았는데, 각각의 관계가 깔끔하게 연관관계인지 의존관계인지 많이 헷갈렸던 것 같습니다. CalculatorItemQueue와 CalculatorItemQueueTest는 직접적으로 의존이 되어 있다기 보다 그냥 연결되어 있다고 생각해서 화살표 없이 작성해보았는데, 라이언은 어떻게 생각하시나요?🧐
저의 경우에는 테스트 메서드가 포함되는 타입은 UML에 포함하지는 않고 있어요. 비즈니스 로직이나 뷰 간의 의존관계를 파악할 때 유용한 도구인데, 테스트 타입과의 의존관계는 없거나 중요하지 않은 경우가 많으니까요.
현재 구현된 수준에서 타입 간의 의존 관계는 없다고 볼 수 있어요. 특정 타입이 본인이 필요로하는 기능을 구현하기 위해 다른 타입의 기능을 사용하여야 하는 경우도 없고, 특정 타입이 다른 타입을 소유하는 경우도 없으니까요. 프로토콜을 유의미하게 준수하는 경우도 없으니 (Int의 경우) 아마 다음 단계에서 타입이 더 많이 구현된다면 더 의미있는 UML을 그릴 수 있지 않을까 생각되네요. 의존, 연관관계가 생기는 시점부터 논의해봅시다~


## ⌨️ 커밋 규칙
* feat    : 기능 추가 (새로운 기능)
* fix      : 버그 수정
* refact : 리팩토링 (네이밍 수정 등)
* style   : 스타일 (코드 형식, 세미콜론 추가: 비즈니스 로직에 변경 없음)
* docs    : 문서 변경 (문서 추가, 수정, 삭제)
* test    : 테스트 (테스트 코드 추가, 수정, 삭제: 비즈니스 로직에 변경 없음)
* chore   : 기타 변경사항 (빌드 스크립트 수정 등)

## 💻 코드 컨벤션
Swift Statements 형식 준수

